###creasecogs gcloud postgres YSms@7Q&rS47K

#!/usr/bin/env python
#
# This illustrates the call-flow required to complete an OAuth request
# against the discogs.com API. The script will download and save a single
# image from the discogs.com API as an example.
# See README.md for further documentation.
#
from asyncio.windows_events import NULL
from io import StringIO
import json
import sys
#import requests

from urllib import request
from urllib.parse import parse_qsl
from urllib.parse import urlparse

import oauth2 as oauth
import pandas as pd
import time
from datetime import datetime
from tqdm import tqdm
import matplotlib.pyplot as plt
import seaborn as sns
import math

# Your consumer key and consumer secret generated by discogs when an application is created
# and registered . See http://www.discogs.com/settings/developers . These credentials
# are assigned by application and remain static for the lifetime of your discogs application.
# the consumer details below were generated for the 'discogs-oauth-example' application.
consumer_key = 'zzBBlgJVPpecQrXqUJSl'
consumer_secret = 'ClmXQCHZSeJvJYUgcrsnRlIMWveQxxcQ'
ptoken = 'xuBymdrHmClmbqsqbeZwTDhsStLddmUcsQaDwJVO'


# The following oauth end-points are defined by discogs.com staff. These static endpoints
# are called at various stages of oauth handshaking.
request_token_url = 'https://api.discogs.com/oauth/request_token'
authorize_url = 'https://www.discogs.com/oauth/authorize'
access_token_url = 'https://api.discogs.com/oauth/access_token'

# A user-agent is required with Discogs API requests. Be sure to make your user-agent
# unique, or you may get a bad response.
user_agent = 'creaseCogs/1.0'

# create oauth Consumer and Client objects using
consumer = oauth.Consumer(consumer_key, consumer_secret)
client = oauth.Client(consumer)

# pass in your consumer key and secret to the token request URL. Discogs returns
# an ouath_request_token as well as an oauth request_token secret.
resp, content = client.request(request_token_url, 'POST', headers={'User-Agent': user_agent})

# we terminate if the discogs api does not return an HTTP 200 OK. Something is
# wrong.
if resp['status'] != '200':
    sys.exit('Invalid response {0}.'.format(resp['status']))

request_token = dict(parse_qsl(content.decode('utf-8')))

print(' == Request Token == ')
print(f'    * oauth_token        = {request_token["oauth_token"]}')
print(f'    * oauth_token_secret = {request_token["oauth_token_secret"]}')
print()

# Authorize our newly received request_token against the discogs oauth endpoint.
# Prompt your user to "accept" the terms of your application. The application
# will act on behalf of their discogs.com account.
# If the user accepts, discogs displays a key to the user that is used for
# verification. The key is required in the 2nd phase of authentication.
print(f'Please browse to the following URL {authorize_url}?oauth_token={request_token["oauth_token"]}')

# Waiting for user input
accepted = 'n'
while accepted.lower() == 'n':
    print()
    accepted = input(f'Have you authorized me at {authorize_url}?oauth_token={request_token["oauth_token"]} [y/n] :')

# request the verification token from the user.
oauth_verifier = input('Verification code : ')

# Generate objects that pass the verification key with the oauth token and oauth
# secret to the discogs access_token_url
token = oauth.Token(request_token['oauth_token'], request_token['oauth_token_secret'])
token.set_verifier(oauth_verifier)
client = oauth.Client(consumer, token)

resp, content = client.request(access_token_url, 'POST', headers={'User-Agent': user_agent})

# if verification is successful, the discogs oauth API will return an access token
# and access token secret. This is the final authentication phase. You should persist
# the oauth_token and the oauth_token_secret to disk, database or some
# other local store. All further requests to the discogs.com API that require authentication
# and must be made with these access_tokens.
access_token = dict(parse_qsl(content.decode('utf-8')))

print(' == Access Token ==')
print(f'    * oauth_token        = {access_token["oauth_token"]}')
print(f'    * oauth_token_secret = {access_token["oauth_token_secret"]}')
print(' Authentication complete. Future requests must be signed with the above tokens.')
print()


# We're now able to fetch an image using the application consumer key and secret,
# along with the verified oauth token and oauth token for this user.
token = oauth.Token(key=access_token['oauth_token'],
        secret=access_token['oauth_token_secret'])
client = oauth.Client(consumer, token)

# With an active auth token, we're able to reuse the client object and request
# additional discogs authenticated endpoints, such as database search.

##get 100 pages of most expensive inventory by user

# https://www.discogs.com/developers/#

## https://api.discogs.com/users/brewerytownbeats/inventory?per_page=100&page=101
## {"message": "Pagination above 100 disabled for inventories besides your own"}

def get_Inventory(sellerName, pageNo=1):
    t = time.process_time()
    print('Getting inventory for ' + str(sellerName))
    resp, content = client.request('https://api.discogs.com/users/' + sellerName + '/inventory?per_page=100&page=' + str(pageNo) + '&sort=price&sort_order=desc',
        headers={'User-Agent': user_agent})
    data = content.decode('utf-8')
    data = json.loads(data)
    
    #create listings objects and placeholder columns

    listings = pd.DataFrame(data.get('listings'))
    listings[['rPrice']] = 1
    listings[['rDescription']] = ''
    listings[['rArtist']] = ''
    listings[['rTitle']] = ''
    listings[['rFormat']] = ''
    listings[['rUrl']] = ''
    listings[['rYear']] = 1 
    listings[['rId']] = 1
    listings[['rCatNo']] = ''
    listings[['seller']] = sellerName
    listings[['want']] = 1
    listings[['have']] = 1
    listings[['timestamp']] = time.asctime()

    # logic for page range less than 100
    pagination = data.get('pagination')

    if pagination is None:
        print('something went wrong getting the inventory for '+ str(sellerName) + '. Moving on...')
        pages = 100
    elif pagination.get('pages') < 100:
        pages = int(pagination.get('pages'))
    else:
        pages = 100

    for pageNo in tqdm(range(pages)):
        resp, content = client.request('https://api.discogs.com/users/' + str(sellerName) + '/inventory?per_page=100&page=' + str(pageNo + 1),
        headers={'User-Agent': user_agent})
        data = content.decode('utf-8')
        data = json.loads(data)

        ##check for None type to avoid "Attribute Error: 'None Type' Object has no attribute 'get'."
        if data is None:
            continue
        else:
            df = pd.DataFrame(data.get('listings'))
            listings = pd.concat([listings, df])

            #check http response for debugging

            if(resp.get('status') != '200'):
                print(resp)
                break

            #throttle every call 
            else:
                time.sleep(.001)
                pageNo +=1
        
        timeSpent = datetime.fromtimestamp(time.process_time() - t)
        timeSpent = timeSpent.strftime('%M:%S')
        print('\n \nPage ' + str(pageNo) + ' complete. It took '+ str(timeSpent) + ' s.')

        for i, row in tqdm((listings.iterrows())):
            time.sleep(0)
            rPrice = listings.iloc[i].price.get('value')
            rDesc = listings.iloc[i].release.get('description')
            rArtist = listings.iloc[i].release.get('artist')
            rFormat = listings.iloc[i].release.get('format')
            rUrl = listings.iloc[i].release.get('resource_url')
            rTitle = listings.iloc[i].release.get('title')
            rYear = listings.iloc[i].release.get('year')
            rId = listings.iloc[i].release.get('id')
            rCatNo = listings.iloc[i].release.get('catalog_number')
            rWant = listings.iloc[i].release.get("stats").get("community").get("in_wantlist")
            rHave = listings.iloc[i].release.get("stats").get("community").get("in_collection")
            listings.at[i, 'rPrice'] = rPrice
            listings.at[i, 'rDesc'] = rDesc
            listings.at[i, 'rArtist'] = rArtist
            listings.at[i, 'rFormat'] = rFormat
            listings.at[i, 'rUrl'] = rUrl
            listings.at[i, 'rTitle'] = rTitle
            listings.at[i, 'rYear'] = rYear
            listings.at[i, 'rId'] = rId
            listings.at[i, 'rCatNo'] = rCatNo
            listings.at[i, 'want'] = rWant
            listings.at[i, 'have'] = rHave
            listings.at[i, 'timestamp'] = time.asctime()
    
    timeSpent = datetime.fromtimestamp(time.process_time() - t)
    timeSpent = timeSpent.strftime('%H:%M:%S')
    print('\nData format complete. ' + str(sellerName) +  ' took '+ str(timeSpent) + 's')

    return listings

philly = ['philadelphiamusic', 'brewerytownbeats', 'creep-records',
         'MilkcrateCafe', 'vinylaltar', 'commonbeatmusic', 'sitandspinrecords',
         'Betternowrecords', 'impressionsphilly']

nj = ['thewaxhut', 'innergrooverecs', 'skyvalley420', 'timzatz',
      'tunesonline', 'recordmuseum', 'phidelityrecords', 'Factory-Record',
      'vinyl_dinosaur', 'clariziomusic']

wc = ['hopfidelity', 'electric_avenue']

pa = ['EastonExchange', 'doubledeckerrecords', 'RECREV', 'Young-Ones-Records',
      'VertigoMusic449', 'WhitsEndTrading', 'impulsebuyrecords', 'dreaminghuman',
      'Lititz_Music_Co.']

dc = ['ByrdlandRecords', 'Jointcustodydc', 'smashdc', 'RecordExchangeofSS', 'Mobius_Records',
      'donutshoppe', 'IRREst.2022']

nyc = ['PrincetonRecordEx', 'recordrunnerusa', 'academyrecords', 'VinylFantasyBrooklyn',
      'Factory-Record', 'humanheadnyc', 'JahAbrams', 'scottisrecordshop', 'recordgrouchbklyn',
      'generationrecords', 'headsoundsrecords', 'facerecordsnyc', 'needleandgrooverec',
      'RoughTradeNYC', 'MUSICONNECTION', 'longgoneday1', 'swoopy', 'Black_Gold_Brooklyn',
      'Psychic_Brooklyn', 'almostready', 'ez2collect2', 'LooneyTunesCDs', 'justtracks',
      'thevinylplant', 'DeepCutsRecordStore']

buffalo = ['RevolverRecordsInc', 'blackdotsbuffalo']

pit = ['gethiprecordings', 'jerrysrecords']

wpaoh = ['JeffmanMusicEmporium', 'statestreetrecords']

bm = ['dj.mikie.love.s', 'normalsrecords', 'deepgroovesounds1', 'BabysOnFireBaltimore']

boston = ['deepthoughtsjp', 'GordonLaSalleVinyl', 'WantListRecords', 'planetrecords',
          'armageddonshop', 'Villagevinylandhifi', 'WannaHearIt', 'lockedgroovellc']

jacksonville = ['Retrofit_Records', 'HearAgainRecords', 'groovyrecordsdeland',
                'Ledzappa1956', 'secretsounds', 'Truetilldeathrecords', 'eraser.jax',
                'tonevendor']

miami = ['TechniqueRecords', 'SweatRecords', 'Vinylasylum']

detroit = ['WeirdsvilleRecords', 'DetroitRecordClub', 'UHF-Records', 'streetcorner12',
           'bradhales', 'dearbornm-farmington', 'RockCityMusicCo', 'Hoppingator',
           'dearbornmusic', 'Slickdiscmusic', 'undergroundsoundsmi']

chicago = ['Morpho_Chicago', 'RoundTripRecords' , 'ToneDeafRecords', 'Wild_Prairie',
           'BucketOBlood', 'Meteor_Gem', 'lets_boogie_records', 'vvmo',
           'Treasuregate', 'ShadyRest.Chicago', '606records', 'bluevillagevinyl',
           'cheapkissrecords', 'TheConservatoryVinyl', 'thedenrecords',
           'trustyspot']

atlanta = []

allem = philly + nj + wc + pa + dc + nyc + bm + wpaoh + pit + buffalo

def get_City(city):
    listings = pd.DataFrame()
    for store in tqdm(city):
        if listings.empty == True:
            listings = get_Inventory(store)
        else:
            newstore = (get_Inventory(store))
            listings = pd.concat([listings, newstore])
    return listings

listings = get_City(allem)

## COMPRESS AND EXPORT LISTINGS

compression_opts = dict(method='zip',
                        archive_name='out.csv')  
listings.to_csv('listings.zip', index=False,
          compression=compression_opts)  

## get mind/near mint 
mint = listings[listings.condition.str.contains("Mint")]

## remove releases w no year for analysis/viz
mint_w_year = mint[mint.rYear != 0]

## mint records priced by year
sns.scatterplot(x='rYear',
                y='rPrice', 
                data=mint_w_year, 
                hue='seller')

plt.show()
plt.close()

#  ##example of GET release
# resp, content = client.request('https://api.discogs.com/releases/97087',
# headers={'User-Agent': user_agent})

def search_Discogs(search=''):
    #https://api.discogs.com/database/search?q={query}&{?genre=disco}?per_page=100&page=1
    resp, content = client.request('https://api.discogs.com/database/search?q='+ search + '&page=1&per_page=100',
        headers={'User-Agent': user_agent})
    data = content.decode('utf-8')
    data = json.loads(data)
    
    return content, data, resp

def get_Collection(username='crease5'):
    print('Getting collection for '+username+', please wait.')
    resp, content = client.request('https://api.discogs.com/users/'+ username + '/collection/folders/0/releases?page=1&per_page=100',
        headers={'User-Agent': user_agent})
    data = content.decode('utf-8')
    data = json.loads(data)

    collection = pd.DataFrame(data.get('releases'))

    pages = data.get('pagination').get('pages')
    for page in tqdm(range(pages)):
        resp, content = client.request('https://api.discogs.com/users/'+ username + '/collection/folders/0/releases?page=' + str(page) + '&per_page=100',
            headers={'User-Agent': user_agent})
        
        data = content.decode('utf-8')
        data = json.loads(data)
        df = pd.DataFrame(data.get('releases'))
        collection = pd.concat([collection, df])

    print('Done grabbing collection. Formatting data...')

    for i, row in tqdm(collection.iterrows()):
        collection.at[i, 'master_id'] = collection.iloc[i].get('basic_information').get('master_id')
        collection.at[i, 'cover_image'] = collection.iloc[i].get('basic_information').get('cover_image')
        collection.at[i, 'mUrl'] = collection.iloc[i].get('basic_information').get('master_url')
        collection.at[i, 'title'] = collection.iloc[i].get('basic_information').get('title')
        collection.at[i, 'year'] = collection.iloc[i].get('basic_information').get('year')
        collection.at[i, 'format'] = collection.iloc[i].basic_information.get('formats')[0].get('name')
        collection.at[i, 'type'] = str(collection.iloc[i].basic_information.get('formats')[0].get('descriptions'))
        collection.at[i, 'labels'] = collection.iloc[i].basic_information.get('labels')[0].get('name')
        collection.at[i, 'lUrl'] = collection.iloc[i].basic_information.get('labels')[0].get('resource_url')
        collection.at[i, 'catno'] = collection.iloc[i].basic_information.get('labels')[0].get('catno')
        collection.at[i, 'lID'] = collection.iloc[i].basic_information.get('labels')[0].get('id')
        collection.at[i, 'artists'] = collection.iloc[i].basic_information.get('artists')[0].get('name')
        collection.at[i, 'aID'] = collection.iloc[i].basic_information.get('artists')[0].get('id')
        collection.at[i, 'aUrl'] = collection.iloc[i].basic_information.get('artists')[0].get('resource_url')
        collection.at[i, 'genre'] = str(collection.iloc[i].basic_information.get('genres'))
        collection.at[i, 'styles'] = str(collection.iloc[i].basic_information.get('styles'))
        
        ## some do not have notes, these return as NaN. This logic helps get past this.
        if  isinstance(collection.iloc[i].notes, float) == True:
            collection.at[i, 'media'] = math.nan
            collection.at[i, 'sleeve'] = math.nan
        else:
            collection.at[i, 'media'] = collection.iloc[i].notes[0].get('value')
            collection.at[i, 'sleeve'] = collection.iloc[i].notes[1].get('value')
    
    return collection, resp

collection, resp = get_Collection()


listings = get_Inventory('sitandspinrecords')

# listings = get_Inventory('theslutbunny')
# listings2 = get_Inventory('philadelphiamusic')





### https://images.google.com/search?engine=google_reverse_image